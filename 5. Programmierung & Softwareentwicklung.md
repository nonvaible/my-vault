# Inhaltsverzeichnis

1. [[#UML-Diagramme (Use Case, Aktivit√§tsdiagramm, Klassendiagramm)]] #erg√§nzen
2. [[#Entwurf von Bildschirmausgabemasken (Softwareergonomie, Corporate Identity, Barrierefreiheit)]]
3. [[#Klassen, Attribute, Objekte, Methoden, Sichtbarkeit]]
4. [[#Skriptsprachen (z.B. Shell-Skripte)]]
5. [[#Abbildung von Kontrollstrukturen (z.B. Verzweigungen, Schleifen) mittels Pseudocode]]
6. [[#Fehler in einem gegebenen Quellcode finden]]
7. [[#Schreibtischtest mit einem gegebenen Quellcode durchf√ºhren]]

----
## UML-Diagramme (Use Case, Aktivit√§tsdiagramm, Klassendiagramm)

Die **Unified Modelling Language (UML)** wird genutzt, um Softwarestrukturen und Abl√§ufe visuell darzustellen.

##### Use-Case-Diagramm (Anwendungsfalldiagramm)

- Zeigt **Funktionen und Interaktionen** zwischen Akteuren und System.
- Besteht aus...:
	- Akteuren (Personen oder externe Systeme, dargestelt als Strichm√§nnchen)
	- Use Cases (Funktionen, dargestellt als Ovale)
	- Beziehungen (Pfeile: "include" und "extend")
###### Beispiel:
Ein Benutzer kann sich in ein System einloggen und Daten speichern.

##### Aktivit√§tsdiagramm

- Zeigt **Ablauf von Prozessen** (z.B.: Login-Prozess)
- Enth√§lt...:
	- Start- und Endpunkte (Kreise)
	- Aktionen (Rechtecke mit abgerundeten Ecken)
	- Verzweigungen (Rauten, z.B. "if-else")
###### Beispiel:
Benutzer gibt Passwort ein -> System pr√ºft Passwort -> Login erfolgreich oder fehlgeschlagen

##### Klassendiagramm

- Zeigt die **Struktur von Klassen in der Software.**
- Enth√§lt...:
	- Klassen (Rechtecke mit Name, Attribute, Methoden)
	- Sichtbarkeiten (+ public, - private, # protected)
	- Beziehungen zwischen Klassen (Vererbung, Assoziation, Aggregration, Komposition)

###### Pr√ºfungsrelevante Themen:
- Welche Diagrammtypen gibt es?
- Wie erkennt man Beziehungen in Klassendiagrammen?
- Wie erstellt man ein Use-Case- oder Aktivit√§tsdiagramm?

#erg√§nzen:f√ºge mal bilder hinzu




---
## Entwurf von Bildschirmausgabemasken (Softwareergonomie, Corporate Identity, Barrierefreiheit)

###### Softwareergonomie:
- Ziel: Einfache und intuitive Benutzeroberfl√§che
- **Gestaltungsrichtlinien:**
	- **Weniger ist mehr** (kein √ºberladenes Interface)
	- **Konsistente Navigation und klare Symbole**
	- **Schnelle Reaktionszeiten** (keine langen Ladezeiten)
###### Corporate Identity (CI):
- Einheitliche Gestaltung von **Farben, Logos, Schriftarten**
- Bsp: Blau und Wei√ü f√ºr Facebook, Rot und Wei√ü f√ºr Youtube.

###### Barrierefreiheit:
- Farben f√ºr Farbenblinde anpassen (hoher Kontrast, keine alleinige Farbcodierung)
- Bedienung mit der Tastatur erm√∂glichen (Tab-Navigation)
- Screenreader-Kompatibilit√§t (alternative Texte f√ºr Bilder)

###### Pr√ºfungsrelevante Themen:
- Was macht eine gute Benutzeroberfl√§che aus?
- Wie werden Accessibility-Standards (z.B. WCAG) umgesetzt?



---
## Klassen, Attribute, Objekte, Methoden, Sichtbarkeit

###### Klasse vs Objekt:
- Eine **Klasse** ist eine Vorlage (oder Bauplan) f√ºr Dinge, die gemeinsame Eigenschaften und Verhalten haben. (z.B. ein Kunde; ein Auto). Technisch gesehen ist eine Klasse eine Definition f√ºr eine komplexe Variable (Objekt)
- Ein **Objekt/Instanz** ist ein konkretes Exemplar einer Klasse. Technisch gesehen sind Objekte Variablen einer Klasse

###### Attribute (Variablen innerhalb einer Klasse)
- Beispiel (Java, weil ich Python hasse):
```java
class Auto {
	String farbe; // Attribut
	int geschwindigkeit; // Attribut
}
```

###### Methoden (Funktionen einer Klasse):
- Beispiel (immer noch Java, weil ich Python hasse):
```java
class Auto {
	void fahren() { // hier kommen die Methode
		System.out.println("Das Auto faehrt.");
	}
}
```

###### Sichtbarkeit (public, private, protected)
- `public +`: sichtbar von jeden anderen Klasse
- `private -`: sichtbar von eigenen Klasse
- `protected #`: _(Vererbung)_ von der eigenen Klasse und abgeleiteten Klasse

###### Pr√ºfungsrelevante Themen:
- Unterschied zwischen Klasse und Objekt
- Bedeutung von `private` und `public`
- Methodenaufrufe und Konstruktoren verstehen

----
## Skriptsprachen (z.B. Shell-Skripte)

###### Bash-Skript (Linux Shell-Skript):
- Automatisierung von Aufgaben in **Linux**
- Bsp: Einfaches Bash-Skript zur Anzeige eines Textes:

```bash
#!/bin/bash
echo "Hallo Welt!"
```

- **Variablen und Schleifen:**

```bash
#!/bin/bash
name="Max"
echo "Hallo $name!"

for var in liste
do
   kommando
   ...
   kommando
done
```

###### PowerShell-Skript (Windows Shell-Skript):
- Automatisierung von Aufgaben in **Windows**\*
- \*) Seit 2016 ist pwsh auch f√ºr \*nix-Systeme verf√ºgbar.
- Bsp: Einfaches pwsh-Skript zur Anzeige eines Textes:
```powershell
Write-Host "Hallo Welt!"
```


- **Variablen und Schleifen:**
```powershell
$name = "Max"
Write-Host "Hallo $name!"

for ($i = 1; $i <= 10; $i++) {
	Write-Host "$name";
}
```

###### Pr√ºfungsrelevante Themen:
- Grundlegender Aufbau eines Skripts
- Schleifen (for, while) und Bedingungen (if)
- Dateimanipulation (ls, cp, mv, grep)




---
## Abbildung von Kontrollstrukturen (z.B. Verzweigungen, Schleifen) mittels Pseudocode

Kontrollstrukturen sind sehr wichtig bei der Erstellung des Algorithmus, und man unterscheidet bei dei prozeduralen Programmierung folgende Kontrollstrukturen:
- [[#Folge (Sequenz)]]
- [[#Auswahl (Selektion)]]
- [[#Wiederholung (Iteration)]]

Abk√ºrzungen:
- G: gemeinsamer Bedingungsteil
- B: Bedingung
- V: Verarbeitung (= Anweisung)


### Folge (Sequenz)

| Programmablaufplan   | Struktogramm         | Pseudocode           |
| -------------------- | -------------------- | -------------------- |
| ![[Auswahl_001.png]] | ![[Auswahl_002.png]] | ![[Auswahl_003.png]] |
Sequenzen sind wirklich "Folgen", also kommen hintereinander und sind einfache Anweisungen, hier wird nichts abgefragt (if-anweisung) oder wird nicht wiedergeholt (loops).


### Auswahl (Selektion)

kurzgesagt: **If-Anweisungen**

Man unterscheidet dabei die:
- bedingte Verarbeitung (if-then)
- einfache Alternative (if-else)
- mehrfache Alternative (switch-case oder if-elseif-else)

###### bedingte Verarbeitung (if-then)


| Programmablaufplan                   | Struktogramm                         | Pseudocode                          |
| ------------------------------------ | ------------------------------------ | ----------------------------------- |
| ![[Pasted image 20250315134158.png]] | ![[Pasted image 20250315134328.png]] | if G = B then<br>       V<br>end if |

###### Einfache Alternative


| Programmablaufplan                   | Struktogramm                         | Pseudocode                           |
| ------------------------------------ | ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20250315134556.png]] | ![[Pasted image 20250315134611.png]] | ![[Pasted image 20250315134622.png]] |


###### Mehrfache Alternative



| Programmablaufplan                   | Struktogramm                         | Pseudocode                           |
| ------------------------------------ | ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20250315134728.png]] | ![[Pasted image 20250315134741.png]] | ![[Pasted image 20250315134756.png]] |



### Wiederholung (Iteration)

Drei Arten von Wiederholungen:
- Kopfgesteuerte Schleife (while - do)
- Fu√ügesteuerte Schleife (do - while)
- Z√§hlschleife (for-Schleife in allen anderen Sprachen au√üer Python)

###### Kopfgesteuerte Schleife

| Programmablaufplan                   | Struktogramm                         | Pseudocode                           |
| ------------------------------------ | ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20250315135213.png]] | ![[Pasted image 20250315135224.png]] | ![[Pasted image 20250315135236.png]] |



###### Fu√ügesteuerte Schleife


| Programmablaufplan                   | Struktogramm                         | Pseudocode                           |
| ------------------------------------ | ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20250315135249.png]] | ![[Pasted image 20250315135301.png]] | ![[Pasted image 20250315135312.png]] |



###### Z√§hlschleife

| Programmablaufplan                   | Struktogramm                         | Pseudocode                           |
| ------------------------------------ | ------------------------------------ | ------------------------------------ |
| ![[Pasted image 20250315135325.png]] | ![[Pasted image 20250315135335.png]] | ![[Pasted image 20250315135347.png]] |
###### √úberblick Kontrollstrukturen
1. Folge (Sequenz)
2. Auswahl (Selektion, Alternative)
	- bedingte Verarbeitung          wenn -> dann
	- einfache Alternative               wenn -> dann -> sonst
	- mehrfache Alternative            wenn Selektor
                                 wert 1 -> dann
	                             wert 2 -> dann
	                             wert n -> dann
	                             sonst -> dann
3. Wiederholung (Schleife, Iteration)
	- kopfgesteuerte Schleife          so lange wie ... -> wiederhole ...
	- fu√ügesteuerte Schleife            wiederhole ... -> so lange bis ...
	- Z√§hlschleife                             z√§hle von ... biss ... Schrittweite ...






---
## Fehler in einem gegebenen Quellcode finden
https://www.youtube.com/watch?v=k4Ccdw-wJ9w
### Highlights

- üõ†Ô∏è **Normalit√§t von Fehlern:** Fehler geh√∂ren zum Alltag eines Entwicklers; es ist wichtig, sie als Teil des Prozesses zu akzeptieren.
- üìù **Wichtigkeit der Tests:** Tests sind essenziell f√ºr die Qualit√§tssicherung und helfen, Fehler fr√ºhzeitig zu erkennen und zu beheben.
- üîç **Fehlersuche-Systematik:** Zun√§chst einen Test schreiben, bevor man mit der Fehlersuche beginnt, um reproduzierbare Bedingungen zu schaffen.
- üîÑ **Darstellungswerkzeuge:** Konsolen-Logs sind oft effektiver als komplexe Debugger, um Fehler schnell zu identifizieren.
- üîç **Ursachenforschung:** Tiefer in die Problematik einsteigen, um die wahren Ursachen der Fehler zu finden, nicht nur die Symptome behandeln.
- ü§ù **Teamarbeit und Kommunikation:** Ein positives Teamklima f√∂rdert die L√∂sung von Fehlern und die Entwicklung eines gemeinsamen Verst√§ndnisses.
- üîÑ **Kontinuierliche Verbesserung:** Reflexion √ºber den Code und Kommunikation im Team helfen, jenseits der aktuellen Probleme zu wachsen.

### Key Insights

- üìâ **Fehler sind unvermeidlich:** Jeder Entwickler muss mit Fehlern rechnen - sie sollten nicht als Misserfolge betrachtet werden, sondern als Lerngelegenheiten. Es ist wichtig, diese Fehler zu analysieren und zu dokumentieren, um das gesamte Entwicklungsteam zu st√§rken.
    
- ‚öôÔ∏è **Die Rolle von Tests:** Tests sollten nicht als blo√üe Aufgaben betrachtet werden, sondern als integrale Teile des Entwicklungsprozesses, die zur F√∂rderung einer solid strukturierten Codebasis beitragen. Jeder Test, der geschrieben wird, verbessert nicht nur die Abdeckung, sondern lehrt auch den Entwickler, wie man allf√§llige zuk√ºnftige Probleme vorwegnimmt.
    
- ‚úÖ **Testen vor Debugging:** Bevor man sich an die Fehlersuche begibt, sollte ein Test geschrieben werden, um den Fehler immer wieder reproduzieren zu k√∂nnen. Dies gew√§hrleistet, dass alle sp√§teren √Ñnderungen gezielt auf den spezifischen Fehler abzielen.
    
- üíª **Nutzung von Tools:** Auch wenn Debugger n√ºtzlich sind, k√∂nnen einfache Logging-Methoden oft effektiver und schneller sein, um die Logik im Code zu verfolgen, besonders bei gut getesteten Anwendungen, wo die Fehler oft bereits bekannt sind.
    
- üîÑ **Tiefe Ursachenanalyse:** Der erste gefundene Grund f√ºr einen Fehler ist oft nicht die wahre Ursache. Entwickler sollten sich nicht scheuen, tiefer zu graben und weitere Fragen zu stellen, um die Situation zu kl√§ren und die grundlegenden Probleme zu identifizieren.
    
- üë©‚Äçüíª **Kollaboration in Teams:** Fehler sollten nicht in einem Vakuum behandelt werden. Das Teilen von Herausforderungen mit Teamkollegen f√ºhrt oft zu neuen Einsichten und ist ein Zeichen f√ºr eine positive Fehlerkultur, die das Lernen und Wachsen innerhalb des Teams f√∂rdert.
    
- üõ†Ô∏è **Reflexion im Code:** Alte und unzufriedenstellende Codeabschnitte sind oft die Wurzel von komplexen Fehlern. Die √úberarbeitung dieser Teile kann nicht nur die aktuelle Anwendungsleistung verbessern, sondern hilft auch, die zugrunde liegenden Probleme zu adressieren und die allgemeine Codequalit√§t zu erh√∂hen.
    

Insgesamt wird eine klare Struktur und ein methodischer Ansatz bei der Fehlersuche und Fehlervermeidung gelegt. Mit der richtigen Einstellung zu Tests, dem Erkennen der Normalit√§t von Fehlern und der F√∂rderung einer positiven Teamdynamik k√∂nnen Entwickler ihre F√§higkeiten verbessern und effektiver arbeiten, w√§hrend sie gleichzeitig ein produktives und lernf√∂rderndes Umfeld schaffen.


(LAUT NOTEGPT falls jemand zu faul f√ºr das ganze Video anzuschauen)




----
## Schreibtischtest mit einem gegebenen Quellcode durchf√ºhren

https://www.youtube.com/watch?v=MY_afAp5tZE

Wir stellen uns vor, dass der Code in unserem Gehirn ausgef√ºhrt wird. Dann zeichnen wir eine Tabelle und tragen die Soll-Ausgaben darauf ein.

